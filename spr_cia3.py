# -*- coding: utf-8 -*-
"""SPR_CIA3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18x7VAtBKcZZE16XsPiSo18keUd-H9b9F
"""

import numpy as np
import librosa
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

# =========================
# Simple helper functions
# =========================

def get_middle_segment(y, sr, dur=0.3):
    mid = len(y)//2
    L = int(dur * sr)
    start = max(0, mid - L//2)
    return y[start:start+L]

def get_formants(frame, sr, order=12):
    frame = frame * np.hamming(len(frame))
    a = librosa.lpc(frame, order=order)
    roots = np.roots(a)
    roots = [r for r in roots if np.imag(r) > 0]

    angs = np.arctan2(np.imag(roots), np.real(roots))
    freqs = sorted(angs * (sr/(2*np.pi)))
    freqs = [f for f in freqs if 90 < f < 4000]

    return freqs[:2] if len(freqs) >= 2 else [np.nan, np.nan]

def extract_f1_f2(y, sr):
    y = y / np.max(np.abs(y))
    y = get_middle_segment(y, sr)

    frames = librosa.util.frame(y, frame_length=400, hop_length=160).T

    f1, f2 = [], []
    for f in frames:
        F1, F2 = get_formants(f, sr)
        f1.append(F1)
        f2.append(F2)

    f1 = np.array(f1)
    f2 = np.array(f2)
    mask = ~np.isnan(f1) & ~np.isnan(f2)

    return np.column_stack((f1[mask], f2[mask]))

# =========================
# Simple DTW
# =========================

def dtw(seq1, seq2):
    n, m = len(seq1), len(seq2)
    cost = np.zeros((n, m))

    for i in range(n):
        for j in range(m):
            cost[i, j] = np.linalg.norm(seq1[i] - seq2[j])

    acc = np.zeros_like(cost)
    acc[0, 0] = cost[0, 0]

    for i in range(1, n):
        acc[i, 0] = cost[i, 0] + acc[i-1, 0]
    for j in range(1, m):
        acc[0, j] = cost[0, j] + acc[0, j-1]

    for i in range(1, n):
        for j in range(1, m):
            acc[i, j] = cost[i, j] + min(acc[i-1, j], acc[i, j-1], acc[i-1, j-1])

    # Backtrack
    i, j = n-1, m-1
    path = [(i, j)]
    while i > 0 or j > 0:
        moves = []
        if i > 0: moves.append(acc[i-1, j])
        else: moves.append(np.inf)
        if j > 0: moves.append(acc[i, j-1])
        else: moves.append(np.inf)
        if i > 0 and j > 0: moves.append(acc[i-1, j-1])
        else: moves.append(np.inf)

        move = np.argmin(moves)
        if move == 0:
            i -= 1
        elif move == 1:
            j -= 1
        else:
            i -= 1
            j -= 1

        path.append((i, j))

    return acc[-1, -1], acc, path

# =========================
# Main
# =========================

def main():
    file1 = "/content/Father1.m4a"
    file2 = "/content/Father2.m4a"

    y1, sr = librosa.load(file1, sr=16000)
    y2, sr = librosa.load(file2, sr=16000)

    feat1 = extract_f1_f2(y1, sr)
    feat2 = extract_f1_f2(y2, sr)

    print("Feature shapes:", feat1.shape, feat2.shape)

    # Plot formants
    plt.figure(figsize=(10,4))
    plt.plot(feat1[:,0], label="Utterance1 F1")
    plt.plot(feat1[:,1], label="Utterance1 F2")
    plt.plot(feat2[:,0], label="Utterance2 F1")
    plt.plot(feat2[:,1], label="Utterance2 F2")
    plt.title("Formant Tracks")
    plt.legend()
    plt.show()

    # DTW
    dist, acc, path = dtw(feat1, feat2)
    print("DTW Distance:", dist)

    p_i = [p[0] for p in path]
    p_j = [p[1] for p in path]

    plt.figure(figsize=(6,5))
    plt.imshow(acc, origin="lower", aspect="auto")
    plt.plot(p_j, p_i, color="white")
    plt.title("DTW Path")
    plt.colorbar()
    plt.show()

if __name__ == "__main__":
    main()

"""The formant plots show how F1 and F2 change over time for both utterances. Even though both recordings are spoken by the same speaker, the shapes of the F1 and F2 curves are not identical because the two spoken phrases contain different vowels and different articulatory movements. The utterance 1 has a stable low F1 and mid range F2 pattern due to the long vowel “a”. The second utterance has more variation in both formants because the speaker moves through multiple vowels. This difference confirms that each word has its own acoustic signature even when spoken by the same person."""

plt.figure(figsize=(12, 6))

plt.subplot(2, 1, 1)
plt.title("Spectrogram: Utterance 1")
spec1 = librosa.amplitude_to_db(np.abs(librosa.stft(y1)), ref=np.max)
librosa.display.specshow(spec1, sr=sr1, x_axis='time', y_axis='hz')
plt.colorbar(format="%+2.f dB")

plt.subplot(2, 1, 2)
plt.title("Spectrogram: Utterance 2")
spec2 = librosa.amplitude_to_db(np.abs(librosa.stft(y2)), ref=np.max)
librosa.display.specshow(spec2, sr=sr2, x_axis='time', y_axis='hz')
plt.colorbar(format="%+2.f dB")

plt.tight_layout()
plt.show()

"""The spectrograms display how energy is spread across frequencies over time. The “father” recording shows a dominant vowel region with strong harmonics and stable formants. The second recording shows more transitions, onsets, and varying energy patterns because it contains multiple syllables. The overall shape remains similar because the speaker identity stays the same, but the internal patterns make each utterance distinct. This shows that spectrograms reflect both linguistic content and speaker characteristics."""

# Ensure features1 and features2 are defined (they are from previous execution)
# Now, perform DTW to get the path
total_cost, cost_matrix, acc_matrix, path = dtw_features(features1, features2)

aligned_f2_1 = []
aligned_f2_2 = []

for (i, j) in path:
    aligned_f2_1.append(features1[i, 1])
    aligned_f2_2.append(features2[j, 1])

plt.figure(figsize=(10, 4))
plt.title("Aligned F2 trajectories using DTW")
plt.plot(aligned_f2_1, label="Utterance 1 (aligned)")
plt.plot(aligned_f2_2, label="Utterance 2 (aligned)")
plt.xlabel("Aligned frame index")
plt.ylabel("F2 (Hz)")
plt.legend()
plt.tight_layout()
plt.show()

"""The DTW distance provides a numeric measure of similarity between the two formant sequences. A lower DTW distance indicates that the two utterances have similar formant structures and timing. A higher DTW distance means the utterances differ more in their acoustic shape. In our case, the DTW distance is relatively high because both utterance use different vowels, producing different formant transitions. Even though the speaker is the same, the formant pathways through the vocal tract are not the same, so the DTW distance increases."""

path_i = [p[0] for p in path]
path_j = [p[1] for p in path]

plt.figure(figsize=(6, 5))
plt.title("DTW local cost matrix with optimal path")
plt.imshow(cost_matrix, origin="lower", aspect="auto")
plt.plot(path_j, path_i, marker=".", markersize=3, color="white")
plt.xlabel("Frames of utterance 2")
plt.ylabel("Frames of utterance 1")
plt.colorbar(label="Local Cost")
plt.tight_layout()
plt.show()

"""**CONCLUSION**

The LPC based formant extraction successfully captures the acoustic structure of each utterance. DTW reveals how different vowel sequences align across time. Since the recordings contain different spoken content, the DTW distance is high and the alignment path is non diagonal. This shows that the two utterances are not acoustically similar, even though they were spoken by the same speaker. The system correctly identifies that the speech content differs significantly, proving that formants and DTW are effective tools for analyzing speech patterns.
"""