# -*- coding: utf-8 -*-
"""SPR_Lab6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t9QvrJ4b0Pq8cixMhCCsOAH0s0Gqjnmf
"""

# ==============================================
# Lab Exercise VI – Dynamic Time Warping (DTW)
# Aim: Compare and align two numerical sequences using DTW
# ==============================================

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# Step 1: Given data
# -------------------------------
v1 = np.array([2, 3, 4, 6, 8, 7, 6, 5, 4, 3, 2])
v2 = np.array([2, 4, 6, 7, 7, 6, 5, 5, 4, 3, 2, 2, 1])

# -------------------------------
# Step 2: Visualize both sequences
# -------------------------------
plt.figure(figsize=(8, 4))
plt.plot(v1, marker='o', label='Vector 1')
plt.plot(v2, marker='s', label='Vector 2')
plt.title('Input Sequences: Vector 1 vs Vector 2')
plt.xlabel('Time index')
plt.ylabel('Amplitude')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# -------------------------------
# Step 3: Implement DTW algorithm
# -------------------------------
def dtw(v1, v2):
    n = len(v1)
    m = len(v2)

    # Local cost matrix: absolute difference between points
    local_cost = np.zeros((n, m))
    for i in range(n):
        for j in range(m):
            local_cost[i, j] = abs(v1[i] - v2[j])

    # Accumulated cost matrix, with padding for easy indexing
    acc_cost = np.full((n + 1, m + 1), np.inf)
    acc_cost[0, 0] = 0

    # Fill accumulated cost matrix
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            cost = local_cost[i - 1, j - 1]
            acc_cost[i, j] = cost + min(
                acc_cost[i - 1, j],     # insertion
                acc_cost[i, j - 1],     # deletion
                acc_cost[i - 1, j - 1]  # match
            )

    # Backtrack to find the optimal warping path
    i, j = n, m
    path = [(i - 1, j - 1)]  # store indices with 0 based convention
    while i > 1 or j > 1:
        # Look at the three neighbors
        choices = [
            acc_cost[i - 1, j],     # up
            acc_cost[i, j - 1],     # left
            acc_cost[i - 1, j - 1]  # diagonal
        ]
        move = np.argmin(choices)

        if move == 0:
            i -= 1
        elif move == 1:
            j -= 1
        else:
            i -= 1
            j -= 1

        path.append((i - 1, j - 1))

    path.reverse()

    # DTW distance is the final accumulated cost
    dtw_distance = acc_cost[n, m]

    return local_cost, acc_cost[1:, 1:], path, dtw_distance


local_cost, acc_cost, path, dtw_distance = dtw(v1, v2)

print("DTW distance between Vector 1 and Vector 2:", dtw_distance)

# -------------------------------
# Step 4: Visualize accumulated cost matrix
# -------------------------------
plt.figure(figsize=(6, 5))
plt.imshow(acc_cost, origin='lower', aspect='auto')
plt.title('Accumulated Cost Matrix')
plt.xlabel('Index of Vector 2')
plt.ylabel('Index of Vector 1')
plt.colorbar(label='Accumulated cost')
plt.tight_layout()
plt.show()

# -------------------------------
# Step 5: Visualize optimal warping path on top of cost matrix
# -------------------------------
plt.figure(figsize=(6, 5))
plt.imshow(acc_cost, origin='lower', aspect='auto')
path_i = [p[0] for p in path]
path_j = [p[1] for p in path]
plt.plot(path_j, path_i, marker='o', linewidth=2)
plt.title('Optimal Warping Path on Accumulated Cost Matrix')
plt.xlabel('Index of Vector 2')
plt.ylabel('Index of Vector 1')
plt.colorbar(label='Accumulated cost')
plt.tight_layout()
plt.show()

# -------------------------------
# Step 6: Optional – visual check of alignment pairs
# -------------------------------
print("Warping path (index pairs i, j):")
for (i, j) in path:
    print(f"v1[{i}] = {v1[i]}  <-->  v2[{j}] = {v2[j]}")